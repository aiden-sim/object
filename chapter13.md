# 서브클래싱과 서브타이핑
- 상속의 용도
  - 1) 타입 계층을 구현하는 것 : 부모 클래스는 자식 클래스의 일반화 이고 자식 클래스는 부모 클래스의 특수화  
  - 2) 코드 재사용 : 간단하게 코드 재사용할 수 있으나 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 수 있음

- 상속을 사용하는 일차적인 목표는 타입 계층 구현을 하는 것 (유연한 설계)
- 타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안됨

- 타입 계층이란 무엇인가?

### 객체지향 프로그래밍과 객체기반 프로그래밍
```
객체기반 프로그래밍 : 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식
객체지향 프로그래밍 : 객체기반 프로그래밍의 한 종류. 객체기반 프로그래밍과 차이점은 상속과 다형성을 지원한다는 점
```

# 01 타입
- 개념 관점의 타입과 프로그래밍 언어 관점의 타입

## 개념 관점의 타입
- 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미
- 어떤 대상의 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부름
  - 일반적으로 타입의 인스턴스를 객체라고 부름

- 타입의 구성 요소
  - 심볼 : 타입에 이름을 붙인 것이다. 앞에서 '프로그래밍 언어'가 타입의 심볼에 해당
  - 내연 : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
  - 외연 : 타입에 속하는 객체들의 집합. '프로그래밍 언어' 타입의 경우에는 자바, 루비, 자바스크립트, C가 속한 집합이 외연을 구성한다. 

- 기타) 클래스, 객체, 인스턴스 차이
  - https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html 

## 프로그래밍 언어 관점의 타입
- 프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용

- 두 가지 목적
  - 1) 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다 
    - ex) 자바에서 '+' 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에서 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없음
    - 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그램저의 실수를 막아줌
  - 2) 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다
    - ex) a +b 라는 연산에서 타입이 int라면 두 수를 더함. String 이라면 두 문자열을 하나로 합침
    - 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입

- 정리
  - 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방자히가 위해 사용 

## 객체지향 패러다임 관점의 타입
- 타입의 두 가지 관점
  - 1) 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
  - 2) 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들이 집합

- 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하하는 것
- 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일

- 객체지향 프로그래밍 관점에서 타입정의
```
객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
```

- 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 함. 객체의 타입을 결정하는 것은 내부 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실

# 02 타입 계층
## 타입 사이의 포함관계
- 타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 됨

- '프로그래밍 언어' 타입의 인스턴스 집합
  - ![스크린샷 2021-04-17 오후 10 35 19](https://user-images.githubusercontent.com/7076334/115115045-36b6e500-9fcd-11eb-9dd7-6bd3ef7f9fc6.png)

- 위의 집합을 좀 더 상세한 기준에 따라 분류
- 타입은 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함
  - ![스크린샷 2021-04-17 오후 10 33 29](https://user-images.githubusercontent.com/7076334/115114983-f5bed080-9fcc-11eb-93b8-3b11d704f7ca.png)

- 타입의 특성
  - 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능
  - 다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있음
  - 다른 타입을 포함하는 타입은 포함되는 타입보다 더 많은 인스터를 가짐 
    - 다시 말해 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 **일반적임**
    - 포함되는 타입은 외연 관점에서 더 작고 내연 관점에서는 더 **특수함**

- 일반화/특수화 관계로 연결된 타입 계층
  - ![스크린샷 2021-04-17 오후 10 44 53](https://user-images.githubusercontent.com/7076334/115115279-8ba72b00-9fce-11eb-9b01-941f5cbdeeff.png)
  - 타입 계층 표현 시, 더 일반적인 타입을 위쪽에, 더 특수한 타입을 아래쪽에 배치
  - 더 일반적인 타입을 **슈퍼타입**
  - 더 특수한 타입을 **서브타입**

- 일반화와 특수화의 정의
```
일반화는 다른 타입을 오나전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
```

- 슈퍼타입과 서브타입 특징
  - 슈퍼타입
    - 집합이 다른 집합의 모든 멤버를 포함
    - 타입 정의가 다른 타입보다 좀 더 일반적 
  - 서브타입 
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함됨
    - 타입 정의가 다른 타입보다 좀 더 구체적

## 객체지향 프로그래밍과 타입 계층
- 객체의 타입을 결정하는 것은 퍼블릭 인터페이스
- 퍼블릭 인터페이스 관점의 슈퍼타입/서브타입
  - 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
  - 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

- 강조
  - 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있음
  - 이 사실이 이번 장의 핵심이자 상속과 다형성의 관계를 이해하기 위한 출발점 

# 03 서브클래싱과 서브타이핑
- 객체지향 프로그래밍 언어에서 **타입**을 구현하는 일반적인 방법은 클래스를 이용하는 것
- **타입 계층**을 구현하는 일반적인 방법은 상속을 이용하는 것
  - 부모 클래스가 슈퍼타입 역할, 자식 클래스가 서브타입 역할

- 서브 타입의 퍼블릭 인터페이스가 특수하다는 것은 어떤 의미일까?

## 언제 상속을 사용해야 하는가?
- 상속의 올바른 용도는 타입 계층을 구현하는 것

- 두 질문을 해보고 '예'라 답할 수 있을 경우에만 상속을 사용 (마틴 오더스키)
  - 1) 상속 관계가 is-a 관계를 모델링하는가?
    - 일반적으로 '자식 클래스'는 '부모 클래스'다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주
    - 두 클래스에 대해 기대하는 행동이 다르면 is-a 관계라도 상속을 사용해서는 안됨
  - 2) 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야함 (행동 호환성)
    - 상속을 결정하기 위해 이 질문에 초점을 맞추는 것이 중요

## is-a 관계
- 마틴 오더스키 : 두 클래스가 어휘적으로 is-a 관계를 모델링할 경우에만 상속을 사용해야 함
  - 참고) 마틴 오드스키 http://www.yes24.com/Product/Goods/96640057
- 스콧 마이어스 : 새와 펭귄의 예를 들어 is-a 관계가 직관을 쉽게 배신할 수 있다는 사실을 보여줌

- 새와 펭귄
  - 펭귄은 새다
  - 새는 날 수 있다 

```
public class Bird {
    public void fly() {

    }
}

public class Penguin extends Bird {
}
```
- 펭귄은 날 수 없지만, 코드는 분명 '펭귄은 새고, 따라서 날 수 있다'라고 주장하고 있음
- 위 예는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여줌
  - 어휘적으로 펭귄은 새지만 새에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 못됨

- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있음. 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있음
  - 새는 울음 소리를 낼 수 있다는 행동을 기대한다면? 새와 펭귄을 타입 계층으로 묶을 수 있음

- 결론
  - 슈퍼타입과 서브타입 관계에서 is-a 보다 행동 호환성이 더 중요
  - 성급하게 상속을 적용하려 하지 말고, is-a를 만족한다면 상속을 사용할 예비 후보 정도로만 생각하자

## 행동 호환성
- 행동이 호환된다는 것은 무슨 의미일까?
  - 중요한 것은 행동의 호환 여부를 판단하는 기준은 **클라이언트의 관점** 이라는 것
  - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있음
  - 타입 계층을 이해하기 위해서는 그 타입 계층이 사용될 문맥을 이해하는 것이 중요

- 펭귄이 새다라는 상속 계층을 유지할 수 있는 3가지 방법
  - 1) Penguin의 fly 메서드 오버라이딩을 구현을 비워 두는 것 
      ```
      public class Penguin extends Bird {
          @Override
          public void fly() {

          }
      }
      ```
      - 어떤 행동도 수행하지 않기 때문에 모든 새가 날 수 있다는 클라이언트의 기대를 만족시키지 못함 (올바른 설계가 아님)


  - 2) Penguin의 fly 메서드 오버라이딩한 후 예외를 던지게 하는 것
      ```
      public class Penguin extends Bird {
          @Override
          public void fly() {
            throw new UnsupportedOperationException();
          }
      }
      ```
      - 역시 클라이언트 관점에서 Bird와 Penguin의 행동이 호환되지 못함


  - 3) flyBird 메서드를 수정해서 Penguin이 아닌 경우에만 fly 메시지를 전송
      ```
      public void flyBird(Bird bird) {
          if (!(bird instanceof Penguin)) {
              bird.fly();
          }
      }
      ```
      - 날 수 없는 새가 계속 추가될 때마다 타입 체크 코드도 추가.
        - 코드를 수정을 요구하기 때문에 개방-폐쇄 원칙을 위반 
      - 구체적인 클래스에 대한 결합도를 높인다.

## 클라이언트의 기대에 따라 계층 분리하기
- 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것
  - 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구 사항을 가진 클라이언트를 만족시킬 수 있을 것

1. 날 수 없는 새와 날 수 있는 새를 분리
```
public class Bird {}

public class FlyingBird extends Bird {
    public void fly() {

    }
}

public class Penguin extends Bird {}

public class Client {
    public void flyBird(FlyingBird bird) {
        bird.fly();
    }
}
```
- Bird가 아닌 FlyingBird에 fly 행동을 구현

- 클라이언트의 기대에 따라 상속 계층을 분리

![스크린샷 2021-04-18 오전 12 03 08](https://user-images.githubusercontent.com/7076334/115117437-813e5e80-9fd9-11eb-9fbd-4d088c3e9b18.png)
- 이제 FlyingBird 타입의 인스턴스만이 fly 메시지를 수신할 수 있음
  - 날 수 엇는 Penguin의 인스턴스에게 fly 메시지를 보낼 방법은 없음
  - 즉 객체와 협력해서 기대했던 행동이 수행되지 않거나 예외가 던져지는 일은 일어나지 않을 것



2. 다른 방법으로 클라이언트에 따라 인터페이스를 분리
- Bird : fly, walk
- Penguin : walk

![스크린샷 2021-04-18 오전 12 03 17](https://user-images.githubusercontent.com/7076334/115117439-826f8b80-9fd9-11eb-95ad-f7c339eca612.png)
- 가장 좋은 방법은 fly 오퍼레이션을 가진 Flyer 인터페이스와 walk 오퍼레이션을 가진 Walker 인터페이스로 분리하는 것
- Bird와 Penguin은 자신이 수행할 수 있는 인터페이스만 구현 하면 됨

```
public interface Flyer {
    void fly();
}

public interface Walker {
    void walk();
}

public class Bird implements Flyer, Walker {
    @Override
    public void fly() {}

    @Override
    public void walk() {}
}

public class Penguin implements Walker {
    @Override
    public void walk() {}
}
```

- Penguin이 Bird의 코드를 재사용해야 한다면?
  - Penguin이 Bird를 상속 받는다면? 퍼블릭 인터페이스에 fly 오퍼레이션이 추가되기 때문에 하면 안됨. 또한 재사용을 위한 상속은 위험
  - 합성을 사용하자 (P.450)
 
- 



- 참고) https://songii00.github.io/2020/04/25/2020-04-25-OBJECTS%20Item%2013/











