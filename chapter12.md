# 다형성
- 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 살펴 봄
- 다형성이 런타임에 메시지를 처리하기위해 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현
- 상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이라는 사실을 이해

# 01 다형성
- 컴퓨터 과학에서는 다형성을 하나의 추상 인터페이스에 대한 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의
  - 간단하게 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

- 다형성의 분류
![polymorphism](https://user-images.githubusercontent.com/7076334/114551414-52a14a80-9c9e-11eb-81b1-bef7569b7231.jpeg)

- 오버로딩 다형성 : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
  - 메서드 이름은 같지만 시그니처 (메서드 이름 + 매개변수 조합) 가 다른 경우
  - 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를 줄일 수 있음

- 강제 다형성 : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킴
  - ex) 플러스 연산자 : 숫자 연산에서는 덧셈으로 사용, 문자열 연산자에는 연결 연산자로 동작
  - 일반적으로 오버로딩 다형성과 강제 다형성을 함께 사용하면 모호해 질 수 있음. 실제로 어떤 메서드가 호출될지를 판단하기 어려워지기 때문

- 매개변수 다형성 : 제네릭 프로그래밍과 관련이 높음. 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킴  
  - ex) 자바의 List 인터페이스

- 포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미
  - 서브타입(Subtype) 다형성이라고 부름
  - 일반적인 다형성을 얘기할 때 포함 다형성을 얘기함
  - ex) DiscountPolicy

- 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것
- 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공

- 이번장의 목표는 포함 다형성의 관점에서 런타임에 상속 계층 안에서 적절한 메서드를 선택하는 방법을 이해하는 것

# 02 상속의 양면성
- 객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것
- 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 됨

- 상속
  - 데이터 관점의 상속 : 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함
  - 행동 관점의 상속 : 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함
  - 이는 재사용 메커니즘으로 보일 수 있지만 상속을 오해한 것이다.

- 상속의 목적은 코드 재사용이 아니라 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것

- 상속의 메커니즘을 이해하는 데 필요한 몇가지 개념들
  - 업캐스팅
  - 동적 메서드 탐색
  - 동적 바인딩
  - self 참조
  - super 참조
    - 이 개념들을 이해하면 상속의 내부 메커니즘뿐만 아니라 타입 계층을 기반으로 한 다형성의 동작 방식을 이해할 수 있게 됨

## 상속을 사용한 강의 평가
### Lecture 클래스 살펴보기
```
Pass:3 Fail:2, A:1 B:1 C:1 D:0 F:2

Pass:3 Fail:2는 강의를 이수한 학생의 수와 낙제한 학생의 수
A:1 B:1 C:1 D:0 F:2는 등급별로 학생들의 분포 현황을 나타냄
```

### 상속을 이용해 Lecture 클래스 재사용하기
- 일반적으로 super는 자식 클래스 내부에서 부모 클래스의 인스턴스 변수나 메서드에 접근하는데 사용 (public, protected)
- 부모 클래스와 자식 클래스에 동일한 시그니처를 가진 메서드가 존재하는 경우 자식 클래스의 메서드 우선순위가 더 높음
- 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것을 메서드 오버라이딩이라고 부름
- 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것을 메서드 오버로딩이라고 부름

- 새로운 클래스를 자식 클래스로 정의하는 것만으로도 원래 클래스가 가지고 있는 데이터와 메서드를 새로운 클래스의 것으로 만들 수 있음

## 데이터 관점의 상속
```
Lecture lecture = new Lecture("객체지향 프로그래밍", 70, Arrays.asList(81, 95, 75, 50, 45));
```

- 위 코드를 메모리 상에 생성된 객체의 모습을 개념적으로 표현
![스크린샷 2021-04-13 오후 10 36 59](https://user-images.githubusercontent.com/7076334/114561738-c9dbdc00-9ca8-11eb-8e61-310f79d8e157.png)

```
Lecture lecture = new GradeLecture("객체지향 프로그래밍",
                      70,
                      Arrays.asList(new Grade("A", 100, 95),
                                    new Grade("B", 94, 80),
                                    new Grade("C", 79, 70),
                                    new Grade("D", 69, 50),
                                    new Grade("F", 49, 0)),
                      Arrays.asList(81, 95, 75, 50, 45));

```

- 위 코드를 메모리 상에 생성된 객체의 모습을 개념적으로 표현
![data_class](https://user-images.githubusercontent.com/7076334/114561206-533ede80-9ca8-11eb-9435-7351fb3c4bbe.jpeg)
- 상속을 인스턴스 관점에서 바라볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것











