## 설계시
- 1) 책임을 먼저 결정(메시지)
- 2) 책임에 적합한 객체 선택 (역할)
- ![스크린샷 2022-02-19 오후 11 31 20](https://user-images.githubusercontent.com/7076334/154805203-459334d2-a6dd-49b5-8f41-e47a01c4848e.png)



## 클래스 설계
- ![스크린샷 2022-02-19 오후 11 34 20](https://user-images.githubusercontent.com/7076334/154805315-74076672-2257-4f90-b25f-401f17c43aed.png)

- 메서드 != 메시지
- 메시지 : 런타임에 받는것
- 메서드 : 코드를 실제로 짜는것. 메시지를 처리하는 방법
- 상태 : 메서드를 구현하는데 필요한 속성


- ![스크린샷 2022-02-19 오후 11 35 39](https://user-images.githubusercontent.com/7076334/154805378-63cf35d0-2f7b-4ee6-bf4b-2740050e8afc.png)
  - 인스턴스 변수는 가장 마지막에 정해져야 한다.

- 인터페이스 도출 : 클라이언트 입장에서 다양한 종류의 객체와 협력이 필요할 때
  - 클라이언트 입장에서 응답할 수 있는지가 중요 하면 인터페이스
  - 구현도 같이 공유가 필요한 경우 추상클래스


## 객체지향 포인트
- 클래스보다 객체가 중요하다.
- 객체보다 메시지가 중요하다.
- 상태보다 행동이 중요하다.
- 메시지와 메서드의 분리는 유연한 설계의 기반이다.

## 절차적
- Process, Data를 나누는 것
- 데이터 부터 확인한다.
  - ERD 부터 구성

## 객체지향적
- Process, Data를 하나로 보는 것
- 행동 부터 확인한다.


## 응집도 / 결합도 / 캡슐화
- 응집도, 결합도, 캡슐화도 변경과 관련

### 응집도
- 클래스 내부의 기능적인 집중도
- 좋은 설계는 응집도가 높은 설계
  - 동일한 기능에 집중
- 응집도는 객체 관점이 아닌 클래스 관점(실제 코딩을 할 때)

#### 변경 관점에서 응집도
- ex) A라는 기능에 의해 변경되고, B라는 기능에도 변경되면 응집도가 낮다. (서로 다른 이유로 변경)
  - 코드 conflic이 많이 나는 이유 
- 단일 책임 원칙(SRP)
  - 각 클래스는 변경될 이유가 하나여야 한다. 

### 결합도
- 클래스가 다른 클래스에 의존하는 정도
- 다른 클래스에 대해 알고 있는 지식의 양 
- 좋은 설계는 결합도가 느슨한 설계

#### 변경 관점에서 결합도
- ![스크린샷 2022-02-20 오후 2 31 52](https://user-images.githubusercontent.com/7076334/154829919-6f8cf8e5-12ef-4111-b6b0-e024fe655f79.png)
- ex) 인터페이스 시그니처가 변경되는 어쩔 수 없지만 10번 중, 1번이 변경된다면 결합도가 낮다고 생각할 수 있다.

- 느슨한 결합도 : 안정적인 추상화에 의존하도록 설계
- 인터페이스 : 협력 관점에서 추상화
- 인터페이스와 구현의 분리 원칙
- ![스크린샷 2022-02-20 오후 2 40 00](https://user-images.githubusercontent.com/7076334/154830134-02507dfd-2def-4b89-9f87-2b6c712cd8f7.png)
  - 인터페이스에 의존
  - 구현을 변경하더라도 파급효과 차단
- ex) String 같이 지원되는 부분은 강하게 결합되도 상관 없다. (거의 변경될 부분이 없으므로) 하지만 우리가 짠 코드는 변경 소지가 높으므로 강하게 결합을 가져가면 문제가 된다.

### 캡슐화
- 상태(데이터)와 행동(메서드)를 함께 모음
- 데이터를 감추고 공용 메서드를 외부에 공개
- 공용 인터페이스 : 외부에 공개된 공용 메서드의 집합

#### 변경 관점에서 캡슐화
- 변경 가능성이 높은 부분을 내부로 숨기는 추상화 기법
- 설계에서 변하는 것이 무엇인지 고민하고 변하는 개념을 캡슐화
- 변경될 수 있는 어떤 것이라도 감추는 것
- ![스크린샷 2022-02-20 오후 2 50 04](https://user-images.githubusercontent.com/7076334/154830385-7d6c7d7d-4c0e-43d1-a179-5f7980e776d9.png)
  - 바뀐게 외부로 세어나가면 안된다. 

#### 데이터 캡슐화 (캡슐화 한 종류)
- 상태(데이터)와 행동(메서드)를 하나의 단위로 묶음
- 데이터를 감추고 공용 인터페이스를 외부에 공개
- 자주 변하는 데이터를 안정적인 공용 인터페이스 뒤로 캡슐화
- ex) 내부 속성이 변경되었다고 공용 인터페이스가 변경되면 데이터 캡슐화가 정상적으로 되지 않았다.

#### 타입 캡슐화
- 자주 변하는 객체의 타입을 추상화 뒤로 캡슐화
- 공통 인터페이스를 제공하는 객체라면 협력 가능
- ex) AmountDiscountPolicy, PercentDiscountPolicy -> DisCountPolicy(interface)
- ![스크린샷 2022-02-20 오후 3 05 59](https://user-images.githubusercontent.com/7076334/154830792-901f082c-ef0e-4b17-9106-0cbcd635c24a.png)
  - 협력해야 하는 타입을 캡슐화 함
  - 의존성 역전 원칙(DIP) : 상위 모듈과 하위 모듈 모두 추상화에 의존

## 설계란?
- 코드를 배치하는 방식 (절차지향, 객체지향)

## 좋은설계란?
- 변경하기 쉽게 코드를 배치하는 것

## 프로그램의 의무
- 두 가지 요구사항 만족
- 우리는 오늘 완성 해야하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 자야 한다.
- 1) 사용자
- 2) 동료 개발자

## SOLID
- 변경하기 쉬운 유연한 설계를 위한 원칙

## 디자인 패턴
- 다양한 디자인 패턴의 목적은 변경을 감추는 것

## 구현과 추상화
- 구현과 추상화의 분리
- 구현 : 자주 변경되는 불안정한 부분
- 추상화 : 자주 변경되지 않는 안정적인 부분

## 정리
- 높은 응집도 : 클래스 안의 코드가 동일한 이유로 변경
- 낮은 결합도 : 클래스의 구현 변경 시 파급효과 제한
- 캡슐화(가장 중요) : 변하는 무엇이든 감추는것

- 메시지 기반으로 나중에 상태가 정해지면 **낮은 결합도**를 갖게 된다.
  - 내부 구현인 데이터가 변경되더라도 외부에 영향을 미치지 않음
  - 데이터 캡슐화
    - ![스크린샷 2022-02-20 오후 6 46 30](https://user-images.githubusercontent.com/7076334/154837044-3840a5f2-db05-4d53-8afc-18663018be86.png)

- 메시지 관점에서 추상화를 하면 **낮은 결합도**를 갖게 된다. 
  - 내부 구현인 데이터가 변경되더라도 외부에 영향을 미치지 않음
  - 타입 캡슐화 
    - ![스크린샷 2022-02-20 오후 6 48 21](https://user-images.githubusercontent.com/7076334/154837092-bb49fe9d-7b25-42e2-bfaf-8cedc1f302c7.png)

- 메시지 기반으로 설계 기반으로 잡아가면 변경하기 쉬운 설계를 얻어갈 수 있다.

## 기타
- 코드리뷰 시, 의존성과 결합도와 캡슐화 관점에서 리뷰를 해야 한다.
- 코드를 본다는 것은 변경이 발생된다는 것이고 변경할려면 코드를 읽어야 하고, 읽으려면 잘 이해해야 한다.
  - 결국 설계는 변경 때문에 중요하다.

