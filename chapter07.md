# 객체 분행
- 인지 과부하
  - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어짐

- 추상화
  - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

- 분해
  - 큰 문제를 해결 가능한 작은 문제로 나누는 작업
  - 목적 : 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것

- 추상화와 분해는 인간의 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구

# 01 프로시저 추상화와 데이터 추상화
- 고수준 언어는 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과
  - 다양한 프로그래밍 패러다임의 탄생으로 이어짐
- 프로그램 패러다임은 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정
- 현대적인 프로그래밍 언어를 특징 짓는 가장 중요한 두 가지 추상화 메커니즘
  - 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지 추상화
  - 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화
- 현재의 설계방법에 중요한 영향을 끼치는 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화를 중심으로 시스템의 분해 방법을 설명

- 프로시저 추상화를 중심으로 시스템 분해
  - 기능 분해 선택 (알고리즘 분해)
- 데이터 추상화를 중심으로 시스템 분해 (둘중 하나 선택)
  - 데이터를 중심으로 타입을 추상화 (추상 데이터 타입)
  - 데이터를 중심으로 프로시저를 추상화 (객체지향)

- 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

# 02 프로시저 추상화와 기능 분해
## 메인 함수로서의 시스템
- 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됨
  - 알고리즘 분해 또는 기능 분해라고 부름
  - 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해됨
- 프로시저는 반복적으로 실행되는 작업들을 하나의 장소에 모아서 재사용하고 중복을 방지하는 추상화 방법
  - 잠재적 정보 은닉을 제공하지만 한계가 있음

- 전통적인 기능 분해 방법은 하향식 접근법을 따름
  - 시스템을 구성하는 가장 최상위 기능을 정의하고 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
  - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지

## 급여 관리 시스템
- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것
- 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정
  - 주연은 기능, 데이터는 기능을 보조하는 조연
- 유지보수에 다양한 문제를 야기함 (밑에서 구체적인 예제)

## 급여 관리 시스템 구현
- 하향식 기능 분해는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해하는 방법
- 하향식은 트리로 표현할 수 있음
- 하향식 기능 분해는 논리적이고 체계적인 시스템 절차를 제시
  - 문제는 우리가 사는 세계는 체계적이지 않다

## 하양식 기능 분해의 문제점
- 다양한 문제점
  - 시스템은 하나의 메인 함수로 구성돼 있지 않다
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

- 하향식 접근법과 기능 분해가 가지는 근본적인 문제는 변경에 취약할 설계

### 하나의 메인 함수라는 비현실적인 아이디어
- 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않음
- 모든 기능은 기능성의 측면에서 동등하고 독립적이고 완결된 하나의 기능을 표현
- 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에 적합

### 메인 함수의 빈번한 재설계
- 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 됨
  - 기존 로직과는 상관없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경
- 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해짐

### 비즈니스 로직과 사용자 인터페이스 결합
- 하향식 

### 성급하게 결정된 실행 순서
- 

### 데이터 변경으로 인한 파급효과
- 



