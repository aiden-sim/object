# 객체 분행
- 인지 과부하
  - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어짐

- 추상화
  - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

- 분해
  - 큰 문제를 해결 가능한 작은 문제로 나누는 작업
  - 목적 : 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것

- 추상화와 분해는 인간의 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구

# 01 프로시저 추상화와 데이터 추상화
- 고수준 언어는 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과
  - 다양한 프로그래밍 패러다임의 탄생으로 이어짐
- 프로그램 패러다임은 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정
- 현대적인 프로그래밍 언어를 특징 짓는 가장 중요한 두 가지 추상화 메커니즘
  - 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지 추상화
  - 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화
- 현재의 설계방법에 중요한 영향을 끼치는 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화를 중심으로 시스템의 분해 방법을 설명

- 프로시저 추상화를 중심으로 시스템 분해
  - 기능 분해 선택 (알고리즘 분해)
- 데이터 추상화를 중심으로 시스템 분해 (둘중 하나 선택)
  - 데이터를 중심으로 타입을 추상화 (추상 데이터 타입)
  - 데이터를 중심으로 프로시저를 추상화 (객체지향)

- 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

# 02 프로시저 추상화와 기능 분해
## 메인 함수로서의 시스템
- 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됨
  - 알고리즘 분해 또는 기능 분해라고 부름
  - 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해됨
- 프로시저는 반복적으로 실행되는 작업들을 하나의 장소에 모아서 재사용하고 중복을 방지하는 추상화 방법
  - 잠재적 정보 은닉을 제공하지만 한계가 있음

- 전통적인 기능 분해 방법은 하향식 접근법을 따름
  - 시스템을 구성하는 가장 최상위 기능을 정의하고 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
  - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지

## 급여 관리 시스템
- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것
- 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정
  - 주연은 기능, 데이터는 기능을 보조하는 조연
- 유지보수에 다양한 문제를 야기함 (밑에서 구체적인 예제)

## 급여 관리 시스템 구현
- 하향식 기능 분해는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해하는 방법
- 하향식은 트리로 표현할 수 있음
- 하향식 기능 분해는 논리적이고 체계적인 시스템 절차를 제시
  - 문제는 우리가 사는 세계는 체계적이지 않다

## 하향식 기능 분해의 문제점
- 다양한 문제점
  - 시스템은 하나의 메인 함수로 구성돼 있지 않다
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

- 하향식 접근법과 기능 분해가 가지는 근본적인 문제는 변경에 취약할 설계

### 하나의 메인 함수라는 비현실적인 아이디어
- 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않음
- 모든 기능은 기능성의 측면에서 동등하고 독립적이고 완결된 하나의 기능을 표현
- 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에 적합

### 메인 함수의 빈번한 재설계
- 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 됨
  - 기존 로직과는 상관없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경
- 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해짐

### 비즈니스 로직과 사용자 인터페이스 결합
- 하향식 접근법은 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요
- 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합됨
- 비즈니스 로직은 적게 변경, 사용자 인터페이스는 자주 변경 되고 두 로직을 한데 섞기 때문에 사용자 인터페이스를 변경 시 비즈니스 로직까지 영향을 받음
  - 변경에 불안정한 아키텍처를 낳음
- 관심사의 분리 라는 아키텍처 설계의 목적을 달성하기 어려움

### 성급하게 결정된 실행 순서
- 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만듬
- 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해할 수 없기 때문에 기능 분해 방식은 중앙집중 제어 스타일의 형태를 띔
  - 함수의 제어 구조가 빈번한 변경 대상
- 객체지향은 함수 간의 호출 순서가 아니라 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나감
  - 어떠한 요소로 제어가 집중되지 않고 여러 객체들 사이로 제어 주체가 분산 
- 하향식 접근법을 통해 분해한 함수들은 재사용하기도 어려움
  - 하위 함수는 항상 상위 함수보다 문맥에 더 종속적
- 하향식 설계와 관련된 모든 문제의 원인은 결합도다.
  - 현재 문맥에 강하게 결합된 시스템은 현재 문맥을 떠나 다른 문맥으로 옮겨갔을 때 재사용하기 어려움


### 데이터 변경으로 인한 파급효과
- 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움
  - 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어려움
- 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 됨
  - 즉 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 됨

## 언제 하향식 분해가 유용한가?
- 하향식 아이디어가 매력적인 이유는 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함
  - 하지만 설계를 문서화하는 데 적절한 방법이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아님 

- 하향식 분해는 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임으로 남아 있음
- 특히 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법


# 03 모듈
## 정보 은닉과 모듈
- 시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것
  - 변경의 방향에 맞춰 시스템을 분해
- 정보 은닉
  - 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것
  - 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리
  - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 함

- 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정
- 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있음

- 모듈은 두 가지 비밀을 감춰야 함
  - 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춤
  - 변경 가능성 : 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
 
- 시스템의 가장 일반적인 비밀은 데이터
  - 비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료구조일 수도 있지만 변경 시 시스템을 굴복시키는 대부분의 경우는 데이터가 변경되는 경우

- 정보 은닉과 데이터 캡슐화
  - 데이터 캡슐화 : 데이터와 메서드를 하나의 단위로 통합하고 퍼블릭 메서드를 통해서만 접근하도록 허용하는 방법
  - 변경과 관련된 비밀을 감춘다는 측면에서 정보 은닉과 캡슐화는 동일한 개념을 가리키는 두 가지 다른 용어지만 데이터 캡슐화는 비밀의 한 종류인 데이터를 감추는 캡슐화의 한 종류 

## 모듈의 장접과 한계
- 장점
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
  - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
  - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다

- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다
- 모듈이 정보 은닉이라는 개념을 통해 데이터라는 존재를 설계의 중심 요소로 부각시켰음 (기능이 아닌 데이터를 중심으로 시스템을 분해) 
- 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위

- 모듈의 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다

# 04 데이터 추상화와 추상 데이터 타입
## 추상 데이터 타입
- 타입
  - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미

- 리스코프는 프로시저 추상화를 보완하기 위해 데이터 추상화의 개념을 제안

- 추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요
  - 타입 정의를 선언할 수 있어야 한다
  - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다
  - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다
  - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다

- 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킴
- 추상 데이터 타입은 데이터에 대한 관점을 설계의 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있음
- 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것

# 05 클래스
## 클래스는 추상 데이터 타입인가?
- 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않음
  - 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하는데 비해 추상 데이터 타입은 지원하지 못함
  - 객체기반 프로그래밍 (추상 데이터 타입 기반의 프로그래밍 페러다임) 

- 쿡의 정의
  - 추상 데이터 타입은 타입을 추상화 한것
  - 클래스는 절차를 추상화 한 것

- 타입 추상화는 오퍼레이션 기준으로 타입을 통합하는 데이터 추상화 기법

- 객체지향은 타입을 기준으로 오퍼레이션을 묶음

- 결론
  - 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 추상화
  - 클래스는 타입 기준으로 절차들을 추상화

## 추상 데이터 타입에서 클래스로 변경하기
- 클라이언트는 메시지를 수신할 객체의 구체적인 클래스에 관해 고민할 필요 없음
  - 수신자가 이해할 것으로 예상되는 메시지를 전송하기만 하면 됨 

## 변경을 기준으로 선택하라
- 타입을 기준으로 절차를 추상화하지 않았따면 그것은 객체지향 분해가 아님
- 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주
- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체

- 개방-폐쇄 원칙
  - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

- 새로운 타입을 빈번하게 추가해야 한다면 객체지향의 클래스 구조가 유용
- 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는 것이 현명한 판단

## 협력이 중요하다
- 객체지향에서 중요한 것은 역할, 책임, 협력
- 객체지향은 기능을 수행하기 위해 객체들이 협력하는 방식에 집중
  - 협력을 고려하지 않고 객체를 고립시킨 채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근이 아님
- 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되어서는 안됨
