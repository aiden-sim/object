# 객체 분행
- 인지 과부하
  - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어짐

- 추상화
  - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

- 분해
  - 큰 문제를 해결 가능한 작은 문제로 나누는 작업
  - 목적 : 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것

- 추상화와 분해는 인간의 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구

# 01 프로시저 추상화와 데이터 추상화
- 고수준 언어는 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과
  - 다양한 프로그래밍 패러다임의 탄생으로 이어짐
- 프로그램 패러다임은 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정
- 현대적인 프로그래밍 언어를 특징 짓는 가장 중요한 두 가지 추상화 메커니즘
  - 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지 추상화
  - 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화
- 현재의 설계방법에 중요한 영향을 끼치는 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화를 중심으로 시스템의 분해 방법을 설명

- 프로시저 추상화를 중심으로 시스템 분해
  - 기능 분해 선택 (알고리즘 분해)
- 데이터 추상화를 중심으로 시스템 분해 (둘중 하나 선택)
  - 데이터를 중심으로 타입을 추상화 (추상 데이터 타입)
  - 데이터를 중심으로 프로시저를 추상화 (객체지향)

- 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

# 02 프로시저 추상화와 기능 분해
## 메인 함수로서의 시스템
- 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됨
  - 알고리즘 분해 또는 기능 분해라고 부름
  - 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해됨
- 프로시저는 반복적으로 실행되는 작업들을 하나의 장소에 모아서 재사용하고 중복을 방지하는 추상화 방법
  - 잠재적 정보 은닉을 제공하지만 한계가 있음

- 전통적인 기능 분해 방법은 하향식 접근법을 따름
  - 시스템을 구성하는 가장 최상위 기능을 정의하고 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
  - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지

## 급여 관리 시스템
- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것
- 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정
  - 주연은 기능, 데이터는 기능을 보조하는 조연
- 유지보수에 다양한 문제를 야기함 (밑에서 구체적인 예제)

## 급여 관리 시스템 구현
- 하향식 기능 분해는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해하는 방법
- 하향식은 트리로 표현할 수 있음
- 하향식 기능 분해는 논리적이고 체계적인 시스템 절차를 제시
  - 문제는 우리가 사는 세계는 체계적이지 않다

## 하양식 기능 분해의 문제점
- 다양한 문제점
  - 시스템은 하나의 메인 함수로 구성돼 있지 않다
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

- 하향식 접근법과 기능 분해가 가지는 근본적인 문제는 변경에 취약할 설계

### 하나의 메인 함수라는 비현실적인 아이디어
- 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않음
- 모든 기능은 기능성의 측면에서 동등하고 독립적이고 완결된 하나의 기능을 표현
- 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에 적합

### 메인 함수의 빈번한 재설계
- 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 됨
  - 기존 로직과는 상관없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경
- 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해짐

### 비즈니스 로직과 사용자 인터페이스 결합
- 하향식 접근법은 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요
- 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합됨
- 비즈니스 로직은 적게 변경, 사용자 인터페이스는 자주 변경 되고 두 로직을 한데 섞기 때문에 사용자 인터페이스를 변경 시 비즈니스 로직까지 영향을 받음
  - 변경에 불안정한 아키텍처를 낳음
- 관심사의 분리 라는 아키텍처 설계의 목적을 달성하기 어려움

### 성급하게 결정된 실행 순서
- 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만듬
- 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해할 수 없기 때문에 기능 분해 방식은 중앙집중 제어 스타일의 형태를 띔
  - 함수의 제어 구조가 빈번한 변경 대상
- 객체지향은 함수 간의 호출 순서가 아니라 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나감
  - 어떠한 요소로 제어가 집중되지 않고 여러 객체들 사이로 제어 주체가 분산 
- 하향식 접근법을 통해 분해한 함수들은 재사용하기도 어려움
  - 하위 함수는 항상 상위 함수보다 문맥에 더 종속적
- 하향식 설계와 관련된 모든 문제의 원인은 결합도다.
  - 현재 문맥에 강하게 결합된 시스템은 현재 문맥을 떠나 다른 문맥으로 옮겨갔을 때 재사용하기 어려움


### 데이터 변경으로 인한 파급효과
- 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움
  - 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어려움
- 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 됨
  - 즉 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 됨

## 언제 하향식 분해가 유용한가?
- 하향식 아이디어가 매력적인 이유는 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함
  - 하지만 설계를 문서화하는 데 적절한 방법이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아님 

- 하향식 분해는 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임으로 남아 있음
```
- 특히 
